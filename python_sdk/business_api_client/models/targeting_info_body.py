# coding: utf-8

"""
 Copyright 2023 TikTok Pte. Ltd.

 This source code is licensed under the MIT license found in
 the LICENSE file in the root directory of this source tree.
"""
import pprint
import re  # noqa: F401

import six

class TargetingInfoBody(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'advertiser_id': 'str',
        'brand_safety_partner': 'str',
        'brand_safety_type': 'str',
        'objective_type': 'str',
        'operating_system': 'str',
        'placements': 'list[str]',
        'promotion_type': 'str',
        'scene': 'str',
        'targeting_ids': 'list[str]'
    }

    attribute_map = {
        'advertiser_id': 'advertiser_id',
        'brand_safety_partner': 'brand_safety_partner',
        'brand_safety_type': 'brand_safety_type',
        'objective_type': 'objective_type',
        'operating_system': 'operating_system',
        'placements': 'placements',
        'promotion_type': 'promotion_type',
        'scene': 'scene',
        'targeting_ids': 'targeting_ids'
    }

    def __init__(self, advertiser_id=None, brand_safety_partner=None, brand_safety_type=None, objective_type=None, operating_system=None, placements=None, promotion_type=None, scene='GEO', targeting_ids=None):  # noqa: E501
        """TargetingInfoBody - a model defined in Swagger"""  # noqa: E501
        self._advertiser_id = None
        self._brand_safety_partner = None
        self._brand_safety_type = None
        self._objective_type = None
        self._operating_system = None
        self._placements = None
        self._promotion_type = None
        self._scene = None
        self._targeting_ids = None
        self.discriminator = None
        self.advertiser_id = advertiser_id
        if brand_safety_partner is not None:
            self.brand_safety_partner = brand_safety_partner
        if brand_safety_type is not None:
            self.brand_safety_type = brand_safety_type
        if objective_type is not None:
            self.objective_type = objective_type
        if operating_system is not None:
            self.operating_system = operating_system
        if placements is not None:
            self.placements = placements
        if promotion_type is not None:
            self.promotion_type = promotion_type
        if scene is not None:
            self.scene = scene
        self.targeting_ids = targeting_ids

    @property
    def advertiser_id(self):
        """Gets the advertiser_id of this TargetingInfoBody.  # noqa: E501

        Advertiser ID.  # noqa: E501

        :return: The advertiser_id of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._advertiser_id

    @advertiser_id.setter
    def advertiser_id(self, advertiser_id):
        """Sets the advertiser_id of this TargetingInfoBody.

        Advertiser ID.  # noqa: E501

        :param advertiser_id: The advertiser_id of this TargetingInfoBody.  # noqa: E501
        :type: str
        """
        if advertiser_id is None:
            raise ValueError("Invalid value for `advertiser_id`, must not be `None`")  # noqa: E501

        self._advertiser_id = advertiser_id

    @property
    def brand_safety_partner(self):
        """Gets the brand_safety_partner of this TargetingInfoBody.  # noqa: E501

        Required only when brand_safety_type is THIRD_PARTY. Brand safety partner. Enum values: IAS, OPEN_SLATE(The partner is named DoubleVerify on TikTok Ads Manager because the partner has been acquired by DoubleVerify). Note: Pre-bid third-party brand safety solutions are currently allowlist-only features. If you would like to access them, please contact your TikTok representative.  # noqa: E501

        :return: The brand_safety_partner of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._brand_safety_partner

    @brand_safety_partner.setter
    def brand_safety_partner(self, brand_safety_partner):
        """Sets the brand_safety_partner of this TargetingInfoBody.

        Required only when brand_safety_type is THIRD_PARTY. Brand safety partner. Enum values: IAS, OPEN_SLATE(The partner is named DoubleVerify on TikTok Ads Manager because the partner has been acquired by DoubleVerify). Note: Pre-bid third-party brand safety solutions are currently allowlist-only features. If you would like to access them, please contact your TikTok representative.  # noqa: E501

        :param brand_safety_partner: The brand_safety_partner of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._brand_safety_partner = brand_safety_partner

    @property
    def brand_safety_type(self):
        """Gets the brand_safety_type of this TargetingInfoBody.  # noqa: E501

        Brand safety type. Valid only when scene is set as GEO and placements is set as PLACEMENT_TIKTOK. Default value: NO_BRAND_SAFETY. Enum values: NO_BRAND_SAFETY: To not use any brand safety solution. Full inventory, which means your ads may appear next to some content featuring mature themes. EXPANDED_INVENTORY: Use TikTok's brand safety solution. Expanded inventory means that your ads will appear next to content where most inappropriate content has been removed, and that does not contain mature themes. In the next API version, EXPANDED_INVENTORY will replace NO_BRAND_SAFETY and will be the default brand safety option. STANDARD_INVENTORY: Use TikTok's brand safety solution. Standard inventory means that ads will appear next to content that is appropriate for most brands. LIMITED_INVENTORY: Use TikTok's brand safety solution. Limited inventory means that your ads will not appear next to content that contains mature themes. THIRD_PARTY: Use a third-party brand safety solution. You also need to pass in a value to the brand_safety_partner field. To get the countries and regions that your ads can be deployed to based on your brand safety settings, use the /tool/region/ endpoint. Note: Pre-bid first-party Brand Safety solutions for APP_PROMOTION, WEB_CONVERSIONS, TRAFFIC, LEAD_GENERATION objectives in Auction ads, and pre-bid third-party brand safety solutions are currently allowlist-only features. If you would like to access them, please contact your TikTok representative. See Brand safety to learn about the supported advertising objectives for pre-bid Brand Safety filtering.  # noqa: E501

        :return: The brand_safety_type of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._brand_safety_type

    @brand_safety_type.setter
    def brand_safety_type(self, brand_safety_type):
        """Sets the brand_safety_type of this TargetingInfoBody.

        Brand safety type. Valid only when scene is set as GEO and placements is set as PLACEMENT_TIKTOK. Default value: NO_BRAND_SAFETY. Enum values: NO_BRAND_SAFETY: To not use any brand safety solution. Full inventory, which means your ads may appear next to some content featuring mature themes. EXPANDED_INVENTORY: Use TikTok's brand safety solution. Expanded inventory means that your ads will appear next to content where most inappropriate content has been removed, and that does not contain mature themes. In the next API version, EXPANDED_INVENTORY will replace NO_BRAND_SAFETY and will be the default brand safety option. STANDARD_INVENTORY: Use TikTok's brand safety solution. Standard inventory means that ads will appear next to content that is appropriate for most brands. LIMITED_INVENTORY: Use TikTok's brand safety solution. Limited inventory means that your ads will not appear next to content that contains mature themes. THIRD_PARTY: Use a third-party brand safety solution. You also need to pass in a value to the brand_safety_partner field. To get the countries and regions that your ads can be deployed to based on your brand safety settings, use the /tool/region/ endpoint. Note: Pre-bid first-party Brand Safety solutions for APP_PROMOTION, WEB_CONVERSIONS, TRAFFIC, LEAD_GENERATION objectives in Auction ads, and pre-bid third-party brand safety solutions are currently allowlist-only features. If you would like to access them, please contact your TikTok representative. See Brand safety to learn about the supported advertising objectives for pre-bid Brand Safety filtering.  # noqa: E501

        :param brand_safety_type: The brand_safety_type of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._brand_safety_type = brand_safety_type

    @property
    def objective_type(self):
        """Gets the objective_type of this TargetingInfoBody.  # noqa: E501

        Required when scene is set as GEO. Campaign objective. The allowed enum values: REACH, TRAFFIC, VIDEO_VIEWS, LEAD_GENERATION, ENGAGEMENT, APP_PROMOTION, WEB_CONVERSIONS, PRODUCT_SALES. For descriptions of the objectives, see Objectives.  # noqa: E501

        :return: The objective_type of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._objective_type

    @objective_type.setter
    def objective_type(self, objective_type):
        """Sets the objective_type of this TargetingInfoBody.

        Required when scene is set as GEO. Campaign objective. The allowed enum values: REACH, TRAFFIC, VIDEO_VIEWS, LEAD_GENERATION, ENGAGEMENT, APP_PROMOTION, WEB_CONVERSIONS, PRODUCT_SALES. For descriptions of the objectives, see Objectives.  # noqa: E501

        :param objective_type: The objective_type of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._objective_type = objective_type

    @property
    def operating_system(self):
        """Gets the operating_system of this TargetingInfoBody.  # noqa: E501

        Valid only when scene is set as GEO. Device operating system that you want to target. Enum values: ANDROID, IOS.  # noqa: E501

        :return: The operating_system of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._operating_system

    @operating_system.setter
    def operating_system(self, operating_system):
        """Sets the operating_system of this TargetingInfoBody.

        Valid only when scene is set as GEO. Device operating system that you want to target. Enum values: ANDROID, IOS.  # noqa: E501

        :param operating_system: The operating_system of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._operating_system = operating_system

    @property
    def placements(self):
        """Gets the placements of this TargetingInfoBody.  # noqa: E501

        Required when scene is set as GEO. The apps where you want to deliver your ads. For enum values, see Enumeration - Placement. Note: If you want to get information about zip code IDs to be used for zip code targeting in the US or postal code IDs to be used for postal code targeting in Canada, the value of this field needs to include PLACEMENT_TIKTOK.  # noqa: E501

        :return: The placements of this TargetingInfoBody.  # noqa: E501
        :rtype: list[str]
        """
        return self._placements

    @placements.setter
    def placements(self, placements):
        """Sets the placements of this TargetingInfoBody.

        Required when scene is set as GEO. The apps where you want to deliver your ads. For enum values, see Enumeration - Placement. Note: If you want to get information about zip code IDs to be used for zip code targeting in the US or postal code IDs to be used for postal code targeting in Canada, the value of this field needs to include PLACEMENT_TIKTOK.  # noqa: E501

        :param placements: The placements of this TargetingInfoBody.  # noqa: E501
        :type: list[str]
        """

        self._placements = placements

    @property
    def promotion_type(self):
        """Gets the promotion_type of this TargetingInfoBody.  # noqa: E501

        Required when scene is set as GEO and objective_type is NOT set as REACH, VIDEO_VIEWS, or ENGAGEMENT. Promotion type and you can decide where you'd like to promote your products using this field. For enum values, see Enumeration - Promotion Type.  # noqa: E501

        :return: The promotion_type of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._promotion_type

    @promotion_type.setter
    def promotion_type(self, promotion_type):
        """Sets the promotion_type of this TargetingInfoBody.

        Required when scene is set as GEO and objective_type is NOT set as REACH, VIDEO_VIEWS, or ENGAGEMENT. Promotion type and you can decide where you'd like to promote your products using this field. For enum values, see Enumeration - Promotion Type.  # noqa: E501

        :param promotion_type: The promotion_type of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._promotion_type = promotion_type

    @property
    def scene(self):
        """Gets the scene of this TargetingInfoBody.  # noqa: E501

        The targeting type that the specified targeting_ids is used for. Enum values: GEO: Geographical targeting, which consists of administrative region targeting and zip code targeting (or postal code targeting). ISP : Internet Service Provider targeting. Default value: GEO.  # noqa: E501

        :return: The scene of this TargetingInfoBody.  # noqa: E501
        :rtype: str
        """
        return self._scene

    @scene.setter
    def scene(self, scene):
        """Sets the scene of this TargetingInfoBody.

        The targeting type that the specified targeting_ids is used for. Enum values: GEO: Geographical targeting, which consists of administrative region targeting and zip code targeting (or postal code targeting). ISP : Internet Service Provider targeting. Default value: GEO.  # noqa: E501

        :param scene: The scene of this TargetingInfoBody.  # noqa: E501
        :type: str
        """

        self._scene = scene

    @property
    def targeting_ids(self):
        """Gets the targeting_ids of this TargetingInfoBody.  # noqa: E501

        Targeting tag IDs. You can pass in location IDs, zip code IDs or postal code IDs, a combination of location IDs, zip code IDs or postal code IDs, or ISP IDs. Max size: 1,000. You can get location IDs, zip code IDs, or postal code IDs via geo_id returned from /tool/targeting/search/, or get location IDs via location_id returned from /tool/region/. You can get ISP IDs via isp_id returned from /tool/targeting/list/.  # noqa: E501

        :return: The targeting_ids of this TargetingInfoBody.  # noqa: E501
        :rtype: list[str]
        """
        return self._targeting_ids

    @targeting_ids.setter
    def targeting_ids(self, targeting_ids):
        """Sets the targeting_ids of this TargetingInfoBody.

        Targeting tag IDs. You can pass in location IDs, zip code IDs or postal code IDs, a combination of location IDs, zip code IDs or postal code IDs, or ISP IDs. Max size: 1,000. You can get location IDs, zip code IDs, or postal code IDs via geo_id returned from /tool/targeting/search/, or get location IDs via location_id returned from /tool/region/. You can get ISP IDs via isp_id returned from /tool/targeting/list/.  # noqa: E501

        :param targeting_ids: The targeting_ids of this TargetingInfoBody.  # noqa: E501
        :type: list[str]
        """
        if targeting_ids is None:
            raise ValueError("Invalid value for `targeting_ids`, must not be `None`")  # noqa: E501

        self._targeting_ids = targeting_ids

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(TargetingInfoBody, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, TargetingInfoBody):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
